// 在WebSocket出现之前，开发实时web应用的方式为轮询：
// 不停的向服务器发送http请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”效果
//缺点：反复发送无效查询请求耗费大量的带宽和cpu资源

WebSocket
// 1、是什么
// WebSocket是一种网络传输协议，位于OSI模型的应用层。可在单个TCP连接上进行全双工通信，能更好地节省服务器资源和带宽并达到实时通讯
// 客户端和服务器端只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输

// 特点
// 全双工：允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合
// 二进制帧
// 采用了二进制帧结构，语法、语义与http完全不兼容，相比http/2，WebSockect更侧重于“实时通信”，而http/2更侧重于提高传输效率，所以两者的帧结构也有很大的区别
// 不像http/2那样定义流，也就不存在多路复用、优先级等特性
// 自身就是全双工，也不需要服务器推送

// 优点
// 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整头部
// 更强的实时性：相对于http请求需要等待客户端发起请求服务器端才能响应，延迟明显更少
// 保持创连接状态：创建通信后，可省略状态信息，不同于http每次请求需要携带身份验证
// 更好的二进制支持：定义了二进制帧，更好处理二进制内容
// 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
// 更好的压缩效果：WebSocket在适当的扩展支持下，可沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

// 应用场景
// 弹幕、媒体聊天、基于位置的应用

// ---------------------------------------------------------------
// 三次握手
// 三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包
// 主要作用为了确认双方的接受能力和发送能力、指定自己的初始化序列号为后面的可靠性传送做准备
// 第一次握手：客户端给服务端发一个SYN报文，并指明客户端初始化序列号ISN（c），此时客户端处于 SYN_SENT状态
// 第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，为了确认客户端的SYN，将客户端的ISN + 1作为ACK的值，此时服务器处于SYN_RCVD状态
// 第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，值为服务器的ISN +1。此时客户端处于ESTABLISHED状态。服务器受到ACK报文之后，也处于ESTABLISHED状态，此时，双方已建立起了连接。

// 第一次握手：客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接受能力是正常的。
// 第二次握手：服务端的发包，客户端收到了，这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接受能力是否正常
// 第三次握手：客户端发包，服务端收到了。这样服务端就能的出结论：客户端的接收、发送能力正常，服务器自己的发送、接受能力也正常

// 四次挥手
// 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态，停止发送数据，等待服务端的确认
// 第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态
// 第三次挥手：如果服务器端也想断开连接，和客户端的第一次挥手一样，发给FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态
// 第四次挥手：客户端收到FIN后，一样发送一个ACK报文作为应答，且把服务端的序列号值+1作为自己ACK豹纹的序列号值，此时客户端处于TIME_WAIT状态。需要过一阵子以确保服务器端受到自己的AKC报文之后才会仅需CLOSED状态，服务端收到ACK报文之后，就处于关闭链接了，处于CLOSED状态
// 四次挥手原因
// 服务端在收到客户端断开连接FIN报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手